package org.edgefog.model;

import java.util.UUID;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;

/**
 * Represents an IoT device that generates computational tasks that can be offloaded
 * to UAV-mounted edge servers or processed locally.
 */
public class IoTDevice {
    private final String id;
    private final IoTNodeLocation location;
    private final double cpuMips;         // Local CPU capacity in MIPS
    private final double memoryMb;        // Local memory in MB
    private final double storageMb;       // Local storage in MB
    private final double batteryCapacity; // Battery capacity in joules
    private double remainingBattery;      // Remaining battery in joules
    
    private final double cpuPowerConsumption; // Power consumption when CPU is active (in watts)
    private final double idlePowerConsumption; // Power consumption when idle (in watts)
    private final double transmitPower;   // Power for transmitting data (in watts)
    
    // Network characteristics
    private final double bandwidth;       // Uplink bandwidth in bits per second
    private final double latency;         // Base network latency in ms
    private final WirelessTechnology wirelessTech; // Type of wireless connection
    
    // Task generation
    private final Random random;
    private final List<Task.TaskType> supportedTaskTypes;
    private final double taskGenerationRate; // Tasks per second
    
    // Metrics tracking
    private int tasksGenerated = 0;
    private int locallyProcessedCount = 0;
    
    private IoTDevice(Builder builder) {
        this.id = builder.id;
        this.location = builder.location;
        this.cpuMips = builder.cpuMips;
        this.memoryMb = builder.memoryMb;
        this.storageMb = builder.storageMb;
        this.batteryCapacity = builder.batteryCapacity;
        this.remainingBattery = builder.batteryCapacity;
        this.cpuPowerConsumption = builder.cpuPowerConsumption;
        this.idlePowerConsumption = builder.idlePowerConsumption;
        this.transmitPower = builder.transmitPower;
        this.bandwidth = builder.bandwidth;
        this.latency = builder.latency;
        this.wirelessTech = builder.wirelessTech;
        this.random = new Random();
        this.supportedTaskTypes = new ArrayList<>(builder.supportedTaskTypes);
        this.taskGenerationRate = builder.taskGenerationRate;
    }
    
    public String getId() {
        return id;
    }
    
    public IoTNodeLocation getLocation() {
        return location;
    }
    
    public double getCpuMips() {
        return cpuMips;
    }
    
    public double getMemoryMb() {
        return memoryMb;
    }
    
    public double getStorageMb() {
        return storageMb;
    }
    
    public double getBatteryCapacity() {
        return batteryCapacity;
    }
    
    public double getRemainingBattery() {
        return remainingBattery;
    }
    
    public double getBatteryPercentage() {
        return (remainingBattery / batteryCapacity) * 100.0;
    }
    
    public double getCpuPowerConsumption() {
        return cpuPowerConsumption;
    }
    
    public double getIdlePowerConsumption() {
        return idlePowerConsumption;
    }
    
    public double getTransmitPower() {
        return transmitPower;
    }
    
    public double getBandwidth() {
        return bandwidth;
    }
    
    public double getLatency() {
        return latency;
    }
    
    public WirelessTechnology getWirelessTech() {
        return wirelessTech;
    }
    
    public double getTaskGenerationRate() {
        return taskGenerationRate;
    }
    
    /**
     * Get the total number of tasks generated by this device
     * @return Number of tasks generated
     */
    public int getTasksGenerated() {
        return tasksGenerated;
    }
    
    /**
     * Get the number of tasks processed locally by this device
     * @return Number of locally processed tasks
     */
    public int getLocallyProcessedCount() {
        return locallyProcessedCount;
    }
    
    /**
     * Consume battery power
     * @param amount Amount of energy to consume in joules
     */
    public void consumeBattery(double amount) {
        remainingBattery = Math.max(0, remainingBattery - amount);
    }
    
    /**
     * Check if the IoT device has enough battery to perform an operation
     * @param requiredEnergy Energy required in joules
     * @return true if sufficient battery available, false otherwise
     */
    public boolean hasSufficientBattery(double requiredEnergy) {
        return remainingBattery >= requiredEnergy;
    }
    
    /**
     * Generate a task based on device characteristics and supported task types
     * @return A new Task instance
     */
    public Task generateTask() {
        if (supportedTaskTypes.isEmpty()) {
            throw new IllegalStateException("Device does not support any task types");
        }
        
        // Increment the tasks generated counter
        tasksGenerated++;
        
        // Randomly select a task type from supported types
        Task.TaskType taskType = supportedTaskTypes.get(random.nextInt(supportedTaskTypes.size()));
        
        // Generate task with some random variation around the average values
        double lengthVariation = 0.5; // ±50% variation
        double sizeVariation = 0.3;   // ±30% variation
        double deadlineVariation = 0.2; // ±20% variation
        
        long length = applyRandomVariation(taskType.getAvgLength(), lengthVariation);
        long inputDataSize = applyRandomVariation(taskType.getAvgInputSize(), sizeVariation);
        long outputDataSize = applyRandomVariation(taskType.getAvgOutputSize(), sizeVariation);
        double deadline = applyRandomVariation(taskType.getAvgDeadline(), deadlineVariation);
        
        // Calculate max energy based on task characteristics and device constraints
        double maxEnergy = Math.min(
            remainingBattery * 0.8,  // Don't use more than 80% of remaining battery
            calculateMaxEnergyForTask(length, inputDataSize)
        );
        
        return new Task.Builder()
                .withLength(length)
                .withInputDataSize(inputDataSize)
                .withOutputDataSize(outputDataSize)
                .withDeadline(deadline)
                .withMaxEnergy(maxEnergy)
                .withSourceLocation(location)
                .withType(taskType)
                .withPriority(taskType.getDefaultPriority())
                .withStatus(Task.TaskStatus.CREATED)
                .build();
    }
    
    /**
     * Calculate maximum energy that could be allocated for a task
     * @param length Task length in MI
     * @param dataSize Data size in bytes
     * @return Maximum energy in joules
     */
    private double calculateMaxEnergyForTask(long length, long dataSize) {
        // Energy for local execution
        double localExecutionEnergy = (length / cpuMips) * cpuPowerConsumption;
        
        // Energy for transmission (if offloaded)
        double transmissionEnergy = (dataSize * 8 / bandwidth) * transmitPower;
        
        // Return the maximum of the two as worst-case energy consumption
        return Math.max(localExecutionEnergy, transmissionEnergy) * 1.2; // Add 20% margin
    }
    
    /**
     * Process a task locally on this device
     * @param task Task to process
     * @return true if processing successful, false if insufficient resources
     */
    public boolean processTaskLocally(Task task) {
        // Calculate energy required to process the task
        double processingTimeSeconds = task.getLength() / cpuMips;
        double energyRequired = processingTimeSeconds * cpuPowerConsumption;
        
        if (remainingBattery < energyRequired) {
            return false; // Not enough battery
        }
        
        if (processingTimeSeconds > task.getDeadline()) {
            return false; // Cannot meet deadline
        }
        
        // Consume battery for processing
        consumeBattery(energyRequired);
        
        // Increment locally processed counter
        locallyProcessedCount++;
        return true;
    }
    
    /**
     * Calculate energy required to offload a task to an edge server
     * @param task Task to offload
     * @param edgeServer Target edge server (UAV)
     * @return Energy required in joules
     */
    public double calculateOffloadingEnergy(Task task, UAV edgeServer) {
        // Calculate data transmission energy
        double distance = location.distanceTo(edgeServer.getLocation());
        double pathLoss = location.calculatePathLoss(edgeServer.getLocation());
        
        // Path loss is a negative value in dB, so we need to reduce power, not increase it
        // Standard energy model: Energy = Transmit power * Time
        double transmitPowerMilliWatts = transmitPower * 1000; // Convert from W to mW
        
        // Time to transmit = data size / effective bandwidth
        double effectiveBandwidth = calculateEffectiveBandwidth(edgeServer, pathLoss);
        double transmissionTimeSeconds = (task.getInputDataSize() * 8) / effectiveBandwidth;
        
        // Use base transmit power - the path loss effect is already factored into the bandwidth calculation
        // Add distance-based energy scaling (quadratic with distance)
        double energyScaleFactor = Math.min(1.0 + (distance / 1000), 3.0); // Cap at 3x scaling
        
        // Energy = power * time * scale factor, convert back to joules
        return (transmitPowerMilliWatts / 1000) * transmissionTimeSeconds * energyScaleFactor;
    }
    
    /**
     * Calculate effective bandwidth to an edge server considering distance and wireless technology
     * @param edgeServer Target edge server
     * @param pathLoss Path loss to the server in dB
     * @return Effective bandwidth in bits per second
     */
    private double calculateEffectiveBandwidth(UAV edgeServer, double pathLoss) {
        // Calculate signal-to-noise ratio
        double transmitPowerDbm = 10 * Math.log10(transmitPower * 1000); // Convert W to dBm
        double noisePowerDbm = -90; // Typical noise floor in dBm
        double snrDb = transmitPowerDbm - pathLoss - noisePowerDbm;
        
        // Shannon capacity: C = B * log2(1 + SNR)
        double snrLinear = Math.pow(10, snrDb / 10);
        double theoreticalCapacity = bandwidth * Math.log(1 + snrLinear) / Math.log(2);
        
        // Account for protocol overhead and other inefficiencies
        double efficiencyFactor = wirelessTech.getEfficiencyFactor();
        
        return theoreticalCapacity * efficiencyFactor;
    }
    
    /**
     * Offload a task to an edge server (UAV)
     * @param task Task to offload
     * @param edgeServer Target edge server
     * @return true if offloading successful, false if insufficient resources
     */
    public boolean offloadTask(Task task, UAV edgeServer) {
        System.out.println("[DEBUG] IoTDevice " + id + ": Attempting to offload task " + task.getId() + " to UAV " + edgeServer.getId());
        
        // Check if UAV is in range
        if (!edgeServer.isInRangeOf(location)) {
            System.out.println("[DEBUG] IoTDevice " + id + ": Offload failed - UAV " + edgeServer.getId() + " not in range");
            return false; // UAV out of range
        }
        
        // Calculate energy required for offloading
        double offloadingEnergy = calculateOffloadingEnergy(task, edgeServer);
        System.out.println("[DEBUG] IoTDevice " + id + ": Offloading energy calculation: required=" + String.format("%.2f", offloadingEnergy) + 
                           "J, available=" + String.format("%.2f", remainingBattery) + "J");
        
        if (remainingBattery < offloadingEnergy) {
            System.out.println("[DEBUG] IoTDevice " + id + ": Offload failed - Not enough battery for offloading");
            return false; // Not enough battery for offloading
        }
        
        // Check if edge server can process the task
        if (!edgeServer.canProcessTask(task)) {
            System.out.println("[DEBUG] IoTDevice " + id + ": Offload failed - UAV " + edgeServer.getId() + " cannot process the task");
            return false; // Edge server cannot process the task
        }
        
        // Update task status and consume battery
        task.setStatus(Task.TaskStatus.TRANSFERRING);
        consumeBattery(offloadingEnergy);
        System.out.println("[DEBUG] IoTDevice " + id + ": Battery consumed for offloading: " + String.format("%.2f", offloadingEnergy) + 
                          "J, remaining: " + String.format("%.2f", remainingBattery) + "J");
        
        // Assign task to edge server
        System.out.println("[DEBUG] IoTDevice " + id + ": Attempting to assign task " + task.getId() + " to UAV " + edgeServer.getId());
        boolean assigned = edgeServer.assignTask(task);
        
        if (assigned) {
            System.out.println("[DEBUG] IoTDevice " + id + ": Task " + task.getId() + " successfully assigned to UAV " + edgeServer.getId());
            task.setStatus(Task.TaskStatus.PROCESSING);
        } else {
            System.out.println("[DEBUG] IoTDevice " + id + ": Task assignment to UAV " + edgeServer.getId() + " failed");
            task.setStatus(Task.TaskStatus.FAILED);
        }
        
        return assigned;
    }
    
    /**
     * Estimate task execution time locally
     * @param task Task to evaluate
     * @return Estimated execution time in seconds
     */
    public double estimateLocalExecutionTime(Task task) {
        return task.getLength() / cpuMips;
    }
    
    /**
     * Estimate total time required to offload and execute a task
     * @param task Task to evaluate
     * @param edgeServer Target edge server
     * @return Estimated total time in seconds
     */
    public double estimateTotalOffloadingTime(Task task, UAV edgeServer) {
        // Calculate transmission time
        double pathLoss = location.calculatePathLoss(edgeServer.getLocation());
        double effectiveBandwidth = calculateEffectiveBandwidth(edgeServer, pathLoss);
        double uploadTime = (task.getInputDataSize() * 8) / effectiveBandwidth;
        
        // Calculate processing time on edge server
        double processingTime = edgeServer.estimateTaskCompletionTime(task);
        
        // Calculate result download time
        double downloadTime = (task.getOutputDataSize() * 8) / effectiveBandwidth;
        
        // Add network latency (round trip)
        double networkLatency = 2 * (latency / 1000.0); // Convert ms to seconds
        
        return uploadTime + processingTime + downloadTime + networkLatency;
    }
    
    /**
     * Apply random variation to a base value within a specified range
     * @param baseValue The base value
     * @param variationRange The variation range (e.g., 0.2 for ±20%)
     * @return The value with random variation applied
     */
    private long applyRandomVariation(long baseValue, double variationRange) {
        double factor = 1.0 + (random.nextDouble() * 2 - 1) * variationRange;
        return Math.max(1, Math.round(baseValue * factor));
    }
    
    /**
     * Apply random variation to a base value within a specified range
     * @param baseValue The base value
     * @param variationRange The variation range (e.g., 0.2 for ±20%)
     * @return The value with random variation applied
     */
    private double applyRandomVariation(double baseValue, double variationRange) {
        double factor = 1.0 + (random.nextDouble() * 2 - 1) * variationRange;
        return Math.max(0.1, baseValue * factor);
    }
    
    @Override
    public String toString() {
        return String.format("IoTDevice{id='%s', location=%s, battery=%.2f%%, types=%s}", 
                id, location, getBatteryPercentage(), supportedTaskTypes);
    }
    
    /**
     * Builder pattern for IoTDevice creation
     */
    public static class Builder {
        private String id;
        private IoTNodeLocation location;
        private double cpuMips = 1000;             // Default: 1000 MIPS
        private double memoryMb = 512;             // Default: 512 MB
        private double storageMb = 1024;           // Default: 1 GB
        private double batteryCapacity = 36000;    // Default: 10 Wh (36000 J)
        private double cpuPowerConsumption = 2.0;  // Default: 2 watts
        private double idlePowerConsumption = 0.5; // Default: 0.5 watts
        private double transmitPower = 0.1;        // Default: 100 mW
        private double bandwidth = 10 * 1024 * 1024; // Default: 10 Mbps
        private double latency = 20;               // Default: 20 ms
        private WirelessTechnology wirelessTech = WirelessTechnology.WIFI;
        private List<Task.TaskType> supportedTaskTypes = new ArrayList<>();
        private double taskGenerationRate = 0.1;   // Default: 0.1 tasks per second
        
        public Builder() {
            this.id = UUID.randomUUID().toString();
            // Add all task types by default
            supportedTaskTypes.add(Task.TaskType.REAL_TIME_VIDEO_ANALYTICS);
            supportedTaskTypes.add(Task.TaskType.ENVIRONMENTAL_MONITORING);
            supportedTaskTypes.add(Task.TaskType.EMERGENCY_RESPONSE);
            supportedTaskTypes.add(Task.TaskType.INDUSTRIAL_CONTROL);
        }
        
        public Builder withId(String id) {
            this.id = id;
            return this;
        }
        
        public Builder withLocation(IoTNodeLocation location) {
            this.location = location;
            return this;
        }
        
        public Builder withCpuMips(double cpuMips) {
            this.cpuMips = cpuMips;
            return this;
        }
        
        public Builder withMemoryMb(double memoryMb) {
            this.memoryMb = memoryMb;
            return this;
        }
        
        public Builder withStorageMb(double storageMb) {
            this.storageMb = storageMb;
            return this;
        }
        
        public Builder withBatteryCapacity(double batteryCapacity) {
            this.batteryCapacity = batteryCapacity;
            return this;
        }
        
        public Builder withCpuPowerConsumption(double cpuPowerConsumption) {
            this.cpuPowerConsumption = cpuPowerConsumption;
            return this;
        }
        
        public Builder withIdlePowerConsumption(double idlePowerConsumption) {
            this.idlePowerConsumption = idlePowerConsumption;
            return this;
        }
        
        public Builder withTransmitPower(double transmitPower) {
            this.transmitPower = transmitPower;
            return this;
        }
        
        public Builder withBandwidth(double bandwidth) {
            this.bandwidth = bandwidth;
            return this;
        }
        
        public Builder withLatency(double latency) {
            this.latency = latency;
            return this;
        }
        
        public Builder withWirelessTechnology(WirelessTechnology wirelessTech) {
            this.wirelessTech = wirelessTech;
            return this;
        }
        
        public Builder withSupportedTaskTypes(List<Task.TaskType> taskTypes) {
            this.supportedTaskTypes = new ArrayList<>(taskTypes);
            return this;
        }
        
        public Builder addSupportedTaskType(Task.TaskType taskType) {
            this.supportedTaskTypes.add(taskType);
            return this;
        }
        
        public Builder withTaskGenerationRate(double taskGenerationRate) {
            this.taskGenerationRate = taskGenerationRate;
            return this;
        }
        
        public IoTDevice build() {
            if (location == null) {
                throw new IllegalStateException("IoT device location cannot be null");
            }
            return new IoTDevice(this);
        }
    }
    
    /**
     * Enum representing different wireless technologies used by IoT devices
     */
    public enum WirelessTechnology {
        WIFI(0.7, 100, 50),              // Wi-Fi with 70% efficiency, 100m range, 50ms handover
        CELLULAR_4G(0.6, 1000, 100),     // 4G with 60% efficiency, 1km range, 100ms handover
        CELLULAR_5G(0.8, 500, 30),       // 5G with 80% efficiency, 500m range, 30ms handover
        BLUETOOTH(0.5, 30, 200),         // Bluetooth with 50% efficiency, 30m range, 200ms handover
        ZIGBEE(0.4, 50, 150),            // ZigBee with 40% efficiency, 50m range, 150ms handover
        LORA(0.3, 5000, 500);            // LoRa with 30% efficiency, 5km range, 500ms handover
        
        private final double efficiencyFactor;  // Protocol efficiency (0-1)
        private final double maxRange;          // Maximum range in meters
        private final double handoverLatency;   // Handover latency in ms
        
        WirelessTechnology(double efficiencyFactor, double maxRange, double handoverLatency) {
            this.efficiencyFactor = efficiencyFactor;
            this.maxRange = maxRange;
            this.handoverLatency = handoverLatency;
        }
        
        public double getEfficiencyFactor() {
            return efficiencyFactor;
        }
        
        public double getMaxRange() {
            return maxRange;
        }
        
        public double getHandoverLatency() {
            return handoverLatency;
        }
    }
}
